# this is a template configuration file
# please rename this template to "config.conf" if you want to use it
# for the client

# ------------------------------------------------------------
# in this section general options are configured
[general]

# absolute path to the logfile
logfile = /absolute/path/to/logfile.log

# valid log levels: DEBUG, INFO, WARNING, ERROR, CRITICAL
loglevel = INFO

# location/address of the server
server = server.h4des.org

# port that is used by the server
serverPort = 12345

# path to the CA file to check the 
# correctness of the used SSL connection
serverCAFile = /absolute/path/to/server_CA.pem

# user credentials of this client
# (have to be unique for each client or strange behavior will happen)
username = user
password = pass

# sets if it is required for the client to authenticate itself
# via a certificate or not (if you have the alert system reachable
# from the internet you should use client certificates)
# ("True" or "False")
certificateRequired = True

# path to the certificate file of the client
# this is used for the SSL connection
# (only processed if "certificateRequired" is set to "True")
certificateFile = /absolute/path/to/client.crt

# path to the key file of the client
# that is used for the SSL connection
# (only processed if "certificateRequired" is set to "True")
keyFile = /absolute/path/to/client.key


# ------------------------------------------------------------
# in this section options for email alerts are configured
[smtp]

# are email alerts active? ("True" or "False")
smtpActivated = True

# address of the used smtp server
# only 127.0.0.1 supported at the moment
server = 127.0.0.1

# port of the used smtp server
serverPort = 25

# email address from which this email should be sent
fromAddr = alertR@h4des.org

# email address to which the email should be sent
toAddr = youraddress@somehost.de


# ------------------------------------------------------------
# section for a single sensor that is managed by this client
# the sections have to be named like this [sensorXYZ]
[sensor1]

# sets the type of the sensor, either an interrupt driven sensor which
# uses edge detection or a polling sensor which just polls the state of the
# gpio pin
# only valid options: interrupt, polling
type = interrupt

# local id of this sensor (has to be unique on this client)
id = 0

# description of this sensor
description = office window top

# raspberry pi gpio pin that is used by this sensor
# NOTE: python uses the actual
# pin number and not the gpio number
gpioPin = 26

# delay after which (when the alert system is still active) the alert should
# trigger (this is processed by the server and the value here is only used
# to register with it at the server)
alertDelay = 0

# alert level which this sensor should trigger
alertLevel = 0

# this flag indicates if this sensor should trigger an alert
# for example it could be just used to signal the state to the server
# and not trigger any alert (regardless of if the alert system is
# active or not)
# ("True" or "False")
triggerAlert = False

# on which internal state the alert should trigger (either 0 or 1)
# for example some sensors trigger with an internal state of 1 and some
# with an internal state of 0
# in order to decide if the sensor has triggered this have to be set to the
# correct value
# regardless on which internal state the sensor will trigger the alert
# system uses for its communication:
# state = 0 => not triggered
# state = 1 => triggered
# (only processed if polling is used)
triggerState = 1

# sets the edge detection that is used by the sensor
# edge = 0 => falling edge
# edge = 1 => rising edge
# (only processed if interrupt is used)
edge = 0

# sets the setting of the gpio if it is pulled up or down
# it is needed to lower a false positive detection rate
# pulledUpOrDown = 0 => pulled down
# pulledUpOrDown = 1 => pulled up
# (only processed if interrupt is used)
pulledUpOrDown = 1

# sets the delay in seconds that is waited until a sensor can trigger again
# this is used to solve problems with the edge detection when the signal
# is bouncing after the taster/switch has been triggered
# (only processed if interrupt is used)
delayBetweenTriggers = 10

# sets the time in seconds how long a sensor should be seen as triggered
# by the alert system
# (only processed if interrupt is used)
timeSensorTriggered = 5

# the count of interrupts that has to occur before an alert is triggered
# this is used to relax the edge detection a little bit
# for example an interrupt is triggered when an falling/rising 
# edge is detected, if your wiring is not good enough isolated
# it can happen that electro magnetic radiation (because of
# a starting vacuum cleaner for example) causes a falling/rising edge
# this option abuses the bouncing of the wiring, this means
# that the radiation for example only triggers one rising/falling
# edge and your normal wiring could cause like four detected edges
# when it is triggered because of the signal bouncing
# so you could use this circumstance to determine correct triggers
# from false triggers by setting a threshold of edges that have
# to be reached before an alert is executed
# (this can be tested with the interrupt helper script from the repository)
# (only processed if interrupt is used)
edgeCountBeforeTrigger = 0


# ------------------------------------------------------------
# section for a single sensor that is managed by this client
# the sections have to be named like this [sensorXYZ]
[sensor2]

# sets the type of the sensor, either an interrupt driven sensor which
# uses edge detection or a polling sensor which just polls the state of the
# gpio pin
# only valid options: interrupt, polling
type = polling

# local id of this sensor (has to be unique on this client)
id = 1

# description of this sensor
description = office window bottom

# raspberry pi gpio pin that is used by this sensor
# NOTE: python uses the actual
# pin number and not the gpio number
gpioPin = 24

# delay after which (when the alert system is still active) the alert should
# trigger (this is processed by the server and the value here is only used
# to register with it at the server)
alertDelay = 0

# alert level which this sensor should trigger
alertLevel = 0

# this flag indicates if this sensor should trigger an alert
# for example it could be just used to signal the state to the server
# and not trigger any alert (regardless of if the alert system is
# active or not)
# ("True" or "False")
triggerAlert = True

# on which internal state the alert should trigger (either 0 or 1)
# for example some sensors trigger with an internal state of 1 and some
# with an internal state of 0
# in order to decide if the sensor has triggered this have to be set to the
# correct value
# regardless on which internal state the sensor will trigger the alert
# system uses for its communication:
# state = 0 => not triggered
# state = 1 => triggered
# (only processed if polling is used)
triggerState = 1

# sets the edge detection that is used by the sensor
# edge = 0 => falling edge
# edge = 1 => rising edge
# (only processed if interrupt is used)
edge = 0

# sets the setting of the gpio if it is pulled up or down
# it is needed to lower a false positive detection rate
# pulledUpOrDown = 0 => pulled down
# pulledUpOrDown = 1 => pulled up
# (only processed if interrupt is used)
pulledUpOrDown = 1

# sets the delay in seconds that is waited until a sensor can trigger again
# this is used to solve problems with the edge detection when the signal
# is bouncing after the taster/switch has been triggered
# (only processed if interrupt is used)
delayBetweenTriggers = 10

# sets the time in seconds how long a sensor should be seen as triggered
# by the alert system
# (only processed if interrupt is used)
timeSensorTriggered = 5

# the count of interrupts that has to occur before an alert is triggered
# this is used to relax the edge detection a little bit
# for example an interrupt is triggered when an falling/rising 
# edge is detected, if your wiring is not good enough isolated
# it can happen that electro magnetic radiation (because of
# a starting vacuum cleaner for example) causes a falling/rising edge
# this option abuses the bouncing of the wiring, this means
# that the radiation for example only triggers one rising/falling
# edge and your normal wiring could cause like four detected edges
# when it is triggered because of the signal bouncing
# so you could use this circumstance to determine correct triggers
# from false triggers by setting a threshold of edges that have
# to be reached before an alert is executed
# (this can be tested with the interrupt helper script from the repository)
# (only processed if interrupt is used)
edgeCountBeforeTrigger = 0